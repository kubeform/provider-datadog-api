/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptions{}).Type1()):          GlobalVariableSpecParseTestOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptionsParser{}).Type1()):    GlobalVariableSpecParseTestOptionsParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepAssertionTargetjsonpath{}).Type1()):      TestSpecApiStepAssertionTargetjsonpathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepExtractedValueParser{}).Type1()):         TestSpecApiStepExtractedValueParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestBasicauth{}).Type1()):             TestSpecApiStepRequestBasicauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificate{}).Type1()):     TestSpecApiStepRequestClientCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateCert{}).Type1()): TestSpecApiStepRequestClientCertificateCertCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateKey{}).Type1()):  TestSpecApiStepRequestClientCertificateKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestDefinition{}).Type1()):            TestSpecApiStepRequestDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecAssertionTargetjsonpath{}).Type1()):             TestSpecAssertionTargetjsonpathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParams{}).Type1()):                   TestSpecBrowserStepParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParamsVariable{}).Type1()):           TestSpecBrowserStepParamsVariableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsList{}).Type1()):                         TestSpecOptionsListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListMonitorOptions{}).Type1()):           TestSpecOptionsListMonitorOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListRetry{}).Type1()):                    TestSpecOptionsListRetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestBasicauth{}).Type1()):                    TestSpecRequestBasicauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificate{}).Type1()):            TestSpecRequestClientCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateCert{}).Type1()):        TestSpecRequestClientCertificateCertCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateKey{}).Type1()):         TestSpecRequestClientCertificateKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestDefinition{}).Type1()):                   TestSpecRequestDefinitionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptions{}).Type1()):          GlobalVariableSpecParseTestOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptionsParser{}).Type1()):    GlobalVariableSpecParseTestOptionsParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepAssertionTargetjsonpath{}).Type1()):      TestSpecApiStepAssertionTargetjsonpathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepExtractedValueParser{}).Type1()):         TestSpecApiStepExtractedValueParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestBasicauth{}).Type1()):             TestSpecApiStepRequestBasicauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificate{}).Type1()):     TestSpecApiStepRequestClientCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateCert{}).Type1()): TestSpecApiStepRequestClientCertificateCertCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateKey{}).Type1()):  TestSpecApiStepRequestClientCertificateKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestDefinition{}).Type1()):            TestSpecApiStepRequestDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecAssertionTargetjsonpath{}).Type1()):             TestSpecAssertionTargetjsonpathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParams{}).Type1()):                   TestSpecBrowserStepParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParamsVariable{}).Type1()):           TestSpecBrowserStepParamsVariableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsList{}).Type1()):                         TestSpecOptionsListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListMonitorOptions{}).Type1()):           TestSpecOptionsListMonitorOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListRetry{}).Type1()):                    TestSpecOptionsListRetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestBasicauth{}).Type1()):                    TestSpecRequestBasicauthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificate{}).Type1()):            TestSpecRequestClientCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateCert{}).Type1()):        TestSpecRequestClientCertificateCertCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateKey{}).Type1()):         TestSpecRequestClientCertificateKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestDefinition{}).Type1()):                   TestSpecRequestDefinitionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GlobalVariableSpecParseTestOptionsCodec struct {
}

func (GlobalVariableSpecParseTestOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GlobalVariableSpecParseTestOptions)(ptr) == nil
}

func (GlobalVariableSpecParseTestOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GlobalVariableSpecParseTestOptions)(ptr)
	var objs []GlobalVariableSpecParseTestOptions
	if obj != nil {
		objs = []GlobalVariableSpecParseTestOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GlobalVariableSpecParseTestOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GlobalVariableSpecParseTestOptions)(ptr) = GlobalVariableSpecParseTestOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GlobalVariableSpecParseTestOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GlobalVariableSpecParseTestOptions)(ptr) = objs[0]
			} else {
				*(*GlobalVariableSpecParseTestOptions)(ptr) = GlobalVariableSpecParseTestOptions{}
			}
		} else {
			*(*GlobalVariableSpecParseTestOptions)(ptr) = GlobalVariableSpecParseTestOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GlobalVariableSpecParseTestOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GlobalVariableSpecParseTestOptions)(ptr) = obj
		} else {
			*(*GlobalVariableSpecParseTestOptions)(ptr) = GlobalVariableSpecParseTestOptions{}
		}
	default:
		iter.ReportError("decode GlobalVariableSpecParseTestOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GlobalVariableSpecParseTestOptionsParserCodec struct {
}

func (GlobalVariableSpecParseTestOptionsParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GlobalVariableSpecParseTestOptionsParser)(ptr) == nil
}

func (GlobalVariableSpecParseTestOptionsParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GlobalVariableSpecParseTestOptionsParser)(ptr)
	var objs []GlobalVariableSpecParseTestOptionsParser
	if obj != nil {
		objs = []GlobalVariableSpecParseTestOptionsParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptionsParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GlobalVariableSpecParseTestOptionsParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = GlobalVariableSpecParseTestOptionsParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GlobalVariableSpecParseTestOptionsParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptionsParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = objs[0]
			} else {
				*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = GlobalVariableSpecParseTestOptionsParser{}
			}
		} else {
			*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = GlobalVariableSpecParseTestOptionsParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GlobalVariableSpecParseTestOptionsParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GlobalVariableSpecParseTestOptionsParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = obj
		} else {
			*(*GlobalVariableSpecParseTestOptionsParser)(ptr) = GlobalVariableSpecParseTestOptionsParser{}
		}
	default:
		iter.ReportError("decode GlobalVariableSpecParseTestOptionsParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepAssertionTargetjsonpathCodec struct {
}

func (TestSpecApiStepAssertionTargetjsonpathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepAssertionTargetjsonpath)(ptr) == nil
}

func (TestSpecApiStepAssertionTargetjsonpathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepAssertionTargetjsonpath)(ptr)
	var objs []TestSpecApiStepAssertionTargetjsonpath
	if obj != nil {
		objs = []TestSpecApiStepAssertionTargetjsonpath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepAssertionTargetjsonpath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepAssertionTargetjsonpathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = TestSpecApiStepAssertionTargetjsonpath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepAssertionTargetjsonpath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepAssertionTargetjsonpath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = TestSpecApiStepAssertionTargetjsonpath{}
			}
		} else {
			*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = TestSpecApiStepAssertionTargetjsonpath{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepAssertionTargetjsonpath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepAssertionTargetjsonpath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = obj
		} else {
			*(*TestSpecApiStepAssertionTargetjsonpath)(ptr) = TestSpecApiStepAssertionTargetjsonpath{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepAssertionTargetjsonpath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepExtractedValueParserCodec struct {
}

func (TestSpecApiStepExtractedValueParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepExtractedValueParser)(ptr) == nil
}

func (TestSpecApiStepExtractedValueParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepExtractedValueParser)(ptr)
	var objs []TestSpecApiStepExtractedValueParser
	if obj != nil {
		objs = []TestSpecApiStepExtractedValueParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepExtractedValueParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepExtractedValueParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepExtractedValueParser)(ptr) = TestSpecApiStepExtractedValueParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepExtractedValueParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepExtractedValueParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepExtractedValueParser)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepExtractedValueParser)(ptr) = TestSpecApiStepExtractedValueParser{}
			}
		} else {
			*(*TestSpecApiStepExtractedValueParser)(ptr) = TestSpecApiStepExtractedValueParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepExtractedValueParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepExtractedValueParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepExtractedValueParser)(ptr) = obj
		} else {
			*(*TestSpecApiStepExtractedValueParser)(ptr) = TestSpecApiStepExtractedValueParser{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepExtractedValueParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepRequestBasicauthCodec struct {
}

func (TestSpecApiStepRequestBasicauthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepRequestBasicauth)(ptr) == nil
}

func (TestSpecApiStepRequestBasicauthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepRequestBasicauth)(ptr)
	var objs []TestSpecApiStepRequestBasicauth
	if obj != nil {
		objs = []TestSpecApiStepRequestBasicauth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestBasicauth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepRequestBasicauthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepRequestBasicauth)(ptr) = TestSpecApiStepRequestBasicauth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepRequestBasicauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestBasicauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepRequestBasicauth)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepRequestBasicauth)(ptr) = TestSpecApiStepRequestBasicauth{}
			}
		} else {
			*(*TestSpecApiStepRequestBasicauth)(ptr) = TestSpecApiStepRequestBasicauth{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepRequestBasicauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestBasicauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepRequestBasicauth)(ptr) = obj
		} else {
			*(*TestSpecApiStepRequestBasicauth)(ptr) = TestSpecApiStepRequestBasicauth{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepRequestBasicauth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepRequestClientCertificateCodec struct {
}

func (TestSpecApiStepRequestClientCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepRequestClientCertificate)(ptr) == nil
}

func (TestSpecApiStepRequestClientCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepRequestClientCertificate)(ptr)
	var objs []TestSpecApiStepRequestClientCertificate
	if obj != nil {
		objs = []TestSpecApiStepRequestClientCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepRequestClientCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepRequestClientCertificate)(ptr) = TestSpecApiStepRequestClientCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepRequestClientCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepRequestClientCertificate)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepRequestClientCertificate)(ptr) = TestSpecApiStepRequestClientCertificate{}
			}
		} else {
			*(*TestSpecApiStepRequestClientCertificate)(ptr) = TestSpecApiStepRequestClientCertificate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepRequestClientCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepRequestClientCertificate)(ptr) = obj
		} else {
			*(*TestSpecApiStepRequestClientCertificate)(ptr) = TestSpecApiStepRequestClientCertificate{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepRequestClientCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepRequestClientCertificateCertCodec struct {
}

func (TestSpecApiStepRequestClientCertificateCertCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepRequestClientCertificateCert)(ptr) == nil
}

func (TestSpecApiStepRequestClientCertificateCertCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepRequestClientCertificateCert)(ptr)
	var objs []TestSpecApiStepRequestClientCertificateCert
	if obj != nil {
		objs = []TestSpecApiStepRequestClientCertificateCert{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateCert{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepRequestClientCertificateCertCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = TestSpecApiStepRequestClientCertificateCert{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepRequestClientCertificateCert

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateCert{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = TestSpecApiStepRequestClientCertificateCert{}
			}
		} else {
			*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = TestSpecApiStepRequestClientCertificateCert{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepRequestClientCertificateCert

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateCert{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = obj
		} else {
			*(*TestSpecApiStepRequestClientCertificateCert)(ptr) = TestSpecApiStepRequestClientCertificateCert{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepRequestClientCertificateCert", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepRequestClientCertificateKeyCodec struct {
}

func (TestSpecApiStepRequestClientCertificateKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepRequestClientCertificateKey)(ptr) == nil
}

func (TestSpecApiStepRequestClientCertificateKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepRequestClientCertificateKey)(ptr)
	var objs []TestSpecApiStepRequestClientCertificateKey
	if obj != nil {
		objs = []TestSpecApiStepRequestClientCertificateKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepRequestClientCertificateKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = TestSpecApiStepRequestClientCertificateKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepRequestClientCertificateKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = TestSpecApiStepRequestClientCertificateKey{}
			}
		} else {
			*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = TestSpecApiStepRequestClientCertificateKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepRequestClientCertificateKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestClientCertificateKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = obj
		} else {
			*(*TestSpecApiStepRequestClientCertificateKey)(ptr) = TestSpecApiStepRequestClientCertificateKey{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepRequestClientCertificateKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecApiStepRequestDefinitionCodec struct {
}

func (TestSpecApiStepRequestDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecApiStepRequestDefinition)(ptr) == nil
}

func (TestSpecApiStepRequestDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecApiStepRequestDefinition)(ptr)
	var objs []TestSpecApiStepRequestDefinition
	if obj != nil {
		objs = []TestSpecApiStepRequestDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecApiStepRequestDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecApiStepRequestDefinition)(ptr) = TestSpecApiStepRequestDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecApiStepRequestDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecApiStepRequestDefinition)(ptr) = objs[0]
			} else {
				*(*TestSpecApiStepRequestDefinition)(ptr) = TestSpecApiStepRequestDefinition{}
			}
		} else {
			*(*TestSpecApiStepRequestDefinition)(ptr) = TestSpecApiStepRequestDefinition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecApiStepRequestDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecApiStepRequestDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecApiStepRequestDefinition)(ptr) = obj
		} else {
			*(*TestSpecApiStepRequestDefinition)(ptr) = TestSpecApiStepRequestDefinition{}
		}
	default:
		iter.ReportError("decode TestSpecApiStepRequestDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecAssertionTargetjsonpathCodec struct {
}

func (TestSpecAssertionTargetjsonpathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecAssertionTargetjsonpath)(ptr) == nil
}

func (TestSpecAssertionTargetjsonpathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecAssertionTargetjsonpath)(ptr)
	var objs []TestSpecAssertionTargetjsonpath
	if obj != nil {
		objs = []TestSpecAssertionTargetjsonpath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecAssertionTargetjsonpath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecAssertionTargetjsonpathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecAssertionTargetjsonpath)(ptr) = TestSpecAssertionTargetjsonpath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecAssertionTargetjsonpath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecAssertionTargetjsonpath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecAssertionTargetjsonpath)(ptr) = objs[0]
			} else {
				*(*TestSpecAssertionTargetjsonpath)(ptr) = TestSpecAssertionTargetjsonpath{}
			}
		} else {
			*(*TestSpecAssertionTargetjsonpath)(ptr) = TestSpecAssertionTargetjsonpath{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecAssertionTargetjsonpath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecAssertionTargetjsonpath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecAssertionTargetjsonpath)(ptr) = obj
		} else {
			*(*TestSpecAssertionTargetjsonpath)(ptr) = TestSpecAssertionTargetjsonpath{}
		}
	default:
		iter.ReportError("decode TestSpecAssertionTargetjsonpath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecBrowserStepParamsCodec struct {
}

func (TestSpecBrowserStepParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecBrowserStepParams)(ptr) == nil
}

func (TestSpecBrowserStepParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecBrowserStepParams)(ptr)
	var objs []TestSpecBrowserStepParams
	if obj != nil {
		objs = []TestSpecBrowserStepParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecBrowserStepParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecBrowserStepParams)(ptr) = TestSpecBrowserStepParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecBrowserStepParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecBrowserStepParams)(ptr) = objs[0]
			} else {
				*(*TestSpecBrowserStepParams)(ptr) = TestSpecBrowserStepParams{}
			}
		} else {
			*(*TestSpecBrowserStepParams)(ptr) = TestSpecBrowserStepParams{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecBrowserStepParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecBrowserStepParams)(ptr) = obj
		} else {
			*(*TestSpecBrowserStepParams)(ptr) = TestSpecBrowserStepParams{}
		}
	default:
		iter.ReportError("decode TestSpecBrowserStepParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecBrowserStepParamsVariableCodec struct {
}

func (TestSpecBrowserStepParamsVariableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecBrowserStepParamsVariable)(ptr) == nil
}

func (TestSpecBrowserStepParamsVariableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecBrowserStepParamsVariable)(ptr)
	var objs []TestSpecBrowserStepParamsVariable
	if obj != nil {
		objs = []TestSpecBrowserStepParamsVariable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParamsVariable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecBrowserStepParamsVariableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecBrowserStepParamsVariable)(ptr) = TestSpecBrowserStepParamsVariable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecBrowserStepParamsVariable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParamsVariable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecBrowserStepParamsVariable)(ptr) = objs[0]
			} else {
				*(*TestSpecBrowserStepParamsVariable)(ptr) = TestSpecBrowserStepParamsVariable{}
			}
		} else {
			*(*TestSpecBrowserStepParamsVariable)(ptr) = TestSpecBrowserStepParamsVariable{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecBrowserStepParamsVariable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecBrowserStepParamsVariable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecBrowserStepParamsVariable)(ptr) = obj
		} else {
			*(*TestSpecBrowserStepParamsVariable)(ptr) = TestSpecBrowserStepParamsVariable{}
		}
	default:
		iter.ReportError("decode TestSpecBrowserStepParamsVariable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecOptionsListCodec struct {
}

func (TestSpecOptionsListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecOptionsList)(ptr) == nil
}

func (TestSpecOptionsListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecOptionsList)(ptr)
	var objs []TestSpecOptionsList
	if obj != nil {
		objs = []TestSpecOptionsList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecOptionsListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecOptionsList)(ptr) = TestSpecOptionsList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecOptionsList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecOptionsList)(ptr) = objs[0]
			} else {
				*(*TestSpecOptionsList)(ptr) = TestSpecOptionsList{}
			}
		} else {
			*(*TestSpecOptionsList)(ptr) = TestSpecOptionsList{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecOptionsList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecOptionsList)(ptr) = obj
		} else {
			*(*TestSpecOptionsList)(ptr) = TestSpecOptionsList{}
		}
	default:
		iter.ReportError("decode TestSpecOptionsList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecOptionsListMonitorOptionsCodec struct {
}

func (TestSpecOptionsListMonitorOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecOptionsListMonitorOptions)(ptr) == nil
}

func (TestSpecOptionsListMonitorOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecOptionsListMonitorOptions)(ptr)
	var objs []TestSpecOptionsListMonitorOptions
	if obj != nil {
		objs = []TestSpecOptionsListMonitorOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListMonitorOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecOptionsListMonitorOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecOptionsListMonitorOptions)(ptr) = TestSpecOptionsListMonitorOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecOptionsListMonitorOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListMonitorOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecOptionsListMonitorOptions)(ptr) = objs[0]
			} else {
				*(*TestSpecOptionsListMonitorOptions)(ptr) = TestSpecOptionsListMonitorOptions{}
			}
		} else {
			*(*TestSpecOptionsListMonitorOptions)(ptr) = TestSpecOptionsListMonitorOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecOptionsListMonitorOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListMonitorOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecOptionsListMonitorOptions)(ptr) = obj
		} else {
			*(*TestSpecOptionsListMonitorOptions)(ptr) = TestSpecOptionsListMonitorOptions{}
		}
	default:
		iter.ReportError("decode TestSpecOptionsListMonitorOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecOptionsListRetryCodec struct {
}

func (TestSpecOptionsListRetryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecOptionsListRetry)(ptr) == nil
}

func (TestSpecOptionsListRetryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecOptionsListRetry)(ptr)
	var objs []TestSpecOptionsListRetry
	if obj != nil {
		objs = []TestSpecOptionsListRetry{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListRetry{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecOptionsListRetryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecOptionsListRetry)(ptr) = TestSpecOptionsListRetry{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecOptionsListRetry

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListRetry{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecOptionsListRetry)(ptr) = objs[0]
			} else {
				*(*TestSpecOptionsListRetry)(ptr) = TestSpecOptionsListRetry{}
			}
		} else {
			*(*TestSpecOptionsListRetry)(ptr) = TestSpecOptionsListRetry{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecOptionsListRetry

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecOptionsListRetry{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecOptionsListRetry)(ptr) = obj
		} else {
			*(*TestSpecOptionsListRetry)(ptr) = TestSpecOptionsListRetry{}
		}
	default:
		iter.ReportError("decode TestSpecOptionsListRetry", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecRequestBasicauthCodec struct {
}

func (TestSpecRequestBasicauthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecRequestBasicauth)(ptr) == nil
}

func (TestSpecRequestBasicauthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecRequestBasicauth)(ptr)
	var objs []TestSpecRequestBasicauth
	if obj != nil {
		objs = []TestSpecRequestBasicauth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestBasicauth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecRequestBasicauthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecRequestBasicauth)(ptr) = TestSpecRequestBasicauth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecRequestBasicauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestBasicauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecRequestBasicauth)(ptr) = objs[0]
			} else {
				*(*TestSpecRequestBasicauth)(ptr) = TestSpecRequestBasicauth{}
			}
		} else {
			*(*TestSpecRequestBasicauth)(ptr) = TestSpecRequestBasicauth{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecRequestBasicauth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestBasicauth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecRequestBasicauth)(ptr) = obj
		} else {
			*(*TestSpecRequestBasicauth)(ptr) = TestSpecRequestBasicauth{}
		}
	default:
		iter.ReportError("decode TestSpecRequestBasicauth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecRequestClientCertificateCodec struct {
}

func (TestSpecRequestClientCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecRequestClientCertificate)(ptr) == nil
}

func (TestSpecRequestClientCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecRequestClientCertificate)(ptr)
	var objs []TestSpecRequestClientCertificate
	if obj != nil {
		objs = []TestSpecRequestClientCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecRequestClientCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecRequestClientCertificate)(ptr) = TestSpecRequestClientCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecRequestClientCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecRequestClientCertificate)(ptr) = objs[0]
			} else {
				*(*TestSpecRequestClientCertificate)(ptr) = TestSpecRequestClientCertificate{}
			}
		} else {
			*(*TestSpecRequestClientCertificate)(ptr) = TestSpecRequestClientCertificate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecRequestClientCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecRequestClientCertificate)(ptr) = obj
		} else {
			*(*TestSpecRequestClientCertificate)(ptr) = TestSpecRequestClientCertificate{}
		}
	default:
		iter.ReportError("decode TestSpecRequestClientCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecRequestClientCertificateCertCodec struct {
}

func (TestSpecRequestClientCertificateCertCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecRequestClientCertificateCert)(ptr) == nil
}

func (TestSpecRequestClientCertificateCertCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecRequestClientCertificateCert)(ptr)
	var objs []TestSpecRequestClientCertificateCert
	if obj != nil {
		objs = []TestSpecRequestClientCertificateCert{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateCert{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecRequestClientCertificateCertCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecRequestClientCertificateCert)(ptr) = TestSpecRequestClientCertificateCert{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecRequestClientCertificateCert

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateCert{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecRequestClientCertificateCert)(ptr) = objs[0]
			} else {
				*(*TestSpecRequestClientCertificateCert)(ptr) = TestSpecRequestClientCertificateCert{}
			}
		} else {
			*(*TestSpecRequestClientCertificateCert)(ptr) = TestSpecRequestClientCertificateCert{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecRequestClientCertificateCert

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateCert{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecRequestClientCertificateCert)(ptr) = obj
		} else {
			*(*TestSpecRequestClientCertificateCert)(ptr) = TestSpecRequestClientCertificateCert{}
		}
	default:
		iter.ReportError("decode TestSpecRequestClientCertificateCert", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecRequestClientCertificateKeyCodec struct {
}

func (TestSpecRequestClientCertificateKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecRequestClientCertificateKey)(ptr) == nil
}

func (TestSpecRequestClientCertificateKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecRequestClientCertificateKey)(ptr)
	var objs []TestSpecRequestClientCertificateKey
	if obj != nil {
		objs = []TestSpecRequestClientCertificateKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecRequestClientCertificateKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecRequestClientCertificateKey)(ptr) = TestSpecRequestClientCertificateKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecRequestClientCertificateKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecRequestClientCertificateKey)(ptr) = objs[0]
			} else {
				*(*TestSpecRequestClientCertificateKey)(ptr) = TestSpecRequestClientCertificateKey{}
			}
		} else {
			*(*TestSpecRequestClientCertificateKey)(ptr) = TestSpecRequestClientCertificateKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecRequestClientCertificateKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestClientCertificateKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecRequestClientCertificateKey)(ptr) = obj
		} else {
			*(*TestSpecRequestClientCertificateKey)(ptr) = TestSpecRequestClientCertificateKey{}
		}
	default:
		iter.ReportError("decode TestSpecRequestClientCertificateKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TestSpecRequestDefinitionCodec struct {
}

func (TestSpecRequestDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TestSpecRequestDefinition)(ptr) == nil
}

func (TestSpecRequestDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TestSpecRequestDefinition)(ptr)
	var objs []TestSpecRequestDefinition
	if obj != nil {
		objs = []TestSpecRequestDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TestSpecRequestDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TestSpecRequestDefinition)(ptr) = TestSpecRequestDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TestSpecRequestDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TestSpecRequestDefinition)(ptr) = objs[0]
			} else {
				*(*TestSpecRequestDefinition)(ptr) = TestSpecRequestDefinition{}
			}
		} else {
			*(*TestSpecRequestDefinition)(ptr) = TestSpecRequestDefinition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TestSpecRequestDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TestSpecRequestDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TestSpecRequestDefinition)(ptr) = obj
		} else {
			*(*TestSpecRequestDefinition)(ptr) = TestSpecRequestDefinition{}
		}
	default:
		iter.ReportError("decode TestSpecRequestDefinition", "unexpected JSON type")
	}
}
